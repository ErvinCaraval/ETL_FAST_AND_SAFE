# Configuración de scripts SQL para Data Warehouse - Versión sin stg_servicios

setup_cleanup: |
  -- 1. Limpieza inicial - Eliminar constraints existentes
  ALTER TABLE fact_servicios DROP CONSTRAINT IF EXISTS pk_fact_servicios;
  ALTER TABLE fact_servicios DROP CONSTRAINT IF EXISTS fk_fact_servicios_tiempo;
  ALTER TABLE fact_servicios DROP CONSTRAINT IF EXISTS fk_fact_servicios_cliente;
  ALTER TABLE fact_servicios DROP CONSTRAINT IF EXISTS fk_fact_servicios_sede_origen;
  ALTER TABLE fact_servicios DROP CONSTRAINT IF EXISTS fk_fact_servicios_sede_destino;
  ALTER TABLE fact_servicios DROP CONSTRAINT IF EXISTS fk_fact_servicios_mensajero;

  ALTER TABLE fact_novedades DROP CONSTRAINT IF EXISTS pk_fact_novedades;
  ALTER TABLE fact_novedades DROP CONSTRAINT IF EXISTS fk_fn_tiempo;
  ALTER TABLE fact_novedades DROP CONSTRAINT IF EXISTS fk_fn_mensajero;
  ALTER TABLE fact_novedades DROP CONSTRAINT IF EXISTS fk_fn_cliente;
  ALTER TABLE fact_novedades DROP CONSTRAINT IF EXISTS fk_fn_sede;

  -- 2. Corregir tipos de datos manteniendo la compatibilidad
  ALTER TABLE dim_tiempo ALTER COLUMN "tiempo_key" TYPE BIGINT USING EXTRACT(EPOCH FROM "tiempo_key")::BIGINT;
  ALTER TABLE fact_servicios ALTER COLUMN "TiempoKey" TYPE BIGINT USING EXTRACT(EPOCH FROM "TiempoKey")::BIGINT;

  ALTER TABLE fact_servicios ALTER COLUMN "SedeOrigenKey" TYPE BIGINT USING CASE WHEN "SedeOrigenKey" IS NOT NULL THEN ROUND("SedeOrigenKey")::BIGINT ELSE NULL END;
  ALTER TABLE fact_servicios ALTER COLUMN "SedeDestinoKey" TYPE BIGINT USING CASE WHEN "SedeDestinoKey" IS NOT NULL THEN ROUND("SedeDestinoKey")::BIGINT ELSE NULL END;

    -- ✅ Reemplazo de NULL por -1000 en SedeDestinoKey antes de cambiar tipo
  UPDATE fact_servicios SET "SedeDestinoKey" = -1000 WHERE "SedeDestinoKey" IS NULL;
  ALTER TABLE fact_servicios ALTER COLUMN "SedeDestinoKey" TYPE BIGINT USING ROUND("SedeDestinoKey")::BIGINT;


  -- ✅ Reemplazo de NULL por -1 en MensajeroKey antes de cambiar tipo
  UPDATE fact_servicios SET "MensajeroKey" = -1 WHERE "MensajeroKey" IS NULL;
  UPDATE fact_novedades SET "MensajeroKey" = -1 WHERE "MensajeroKey" IS NULL;

  ALTER TABLE fact_servicios ALTER COLUMN "MensajeroKey" TYPE BIGINT USING ROUND("MensajeroKey")::BIGINT;

  ALTER TABLE fact_novedades ALTER COLUMN "TiempoKey" TYPE BIGINT USING EXTRACT(EPOCH FROM "TiempoKey")::BIGINT;
  ALTER TABLE fact_novedades ALTER COLUMN "SedeKey" TYPE BIGINT USING CASE WHEN "SedeKey" IS NOT NULL THEN ROUND("SedeKey")::BIGINT ELSE NULL END;
  ALTER TABLE fact_novedades ALTER COLUMN "MensajeroKey" TYPE BIGINT USING ROUND("MensajeroKey")::BIGINT;

dimensions_pk: |
  -- 3. PKs en dimensiones
  ALTER TABLE dim_cliente ADD CONSTRAINT pk_cliente PRIMARY KEY ("ClienteKey");
  ALTER TABLE dim_mensajero ADD CONSTRAINT pk_mensajero PRIMARY KEY ("MensajeroKey");
  ALTER TABLE dim_sede ADD CONSTRAINT pk_sede PRIMARY KEY ("SedeKey");
  ALTER TABLE dim_tiempo ADD CONSTRAINT pk_tiempo PRIMARY KEY ("tiempo_key");

  -- ✅ Inserción de fila dummy para -1 en dim_mensajero para mantener integridad referencial
  INSERT INTO dim_mensajero ("MensajeroKey","user_id","first_name","last_name","telefono")
  VALUES (-1,333,'NONE','NONE','000-0000-000')
  ON CONFLICT ("MensajeroKey") DO NOTHING;

  -- ✅ Inserción de fila dummy para -1 en dim_sede como 'NO IDENTIFICADA'
  INSERT INTO dim_sede ("SedeKey", nombre)
  VALUES (-1000, 'NO IDENTIFICADA')
  ON CONFLICT ("SedeKey") DO NOTHING;

facts_pk: |
  -- 4. Nueva estrategia para PKs en hechos con manejo de duplicados
  DO $$
  BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                  WHERE table_name = 'fact_servicios' AND column_name = 'servicio_id') THEN
      ALTER TABLE fact_servicios ADD COLUMN servicio_id SERIAL;
      UPDATE fact_servicios SET servicio_id = nextval(pg_get_serial_sequence('fact_servicios', 'servicio_id'));
    END IF;
  END $$;

  ALTER TABLE fact_servicios
    ADD CONSTRAINT pk_fact_servicios PRIMARY KEY (servicio_id);
  COMMENT ON CONSTRAINT pk_fact_servicios ON fact_servicios IS 'Llave primaria artificial para servicios (permite duplicados en campos naturales)';

  CREATE UNIQUE INDEX IF NOT EXISTS idx_servicio_unico 
    ON fact_servicios ("ServicioKey", "TiempoKey", "ClienteKey", "SedeOrigenKey", "SedeDestinoKey");
  COMMENT ON INDEX idx_servicio_unico IS 'Índice para controlar registros realmente duplicados';

  DO $$
  BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                  WHERE table_name = 'fact_novedades' AND column_name = 'NovedadKey') THEN
      ALTER TABLE fact_novedades ADD COLUMN "NovedadKey" SERIAL;
    END IF;
  END $$;

  ALTER TABLE fact_novedades
    ADD CONSTRAINT pk_fact_novedades PRIMARY KEY ("NovedadKey");

facts_fk_servicios: |
  -- 5. FKs para fact_servicios
  ALTER TABLE fact_servicios
    ADD CONSTRAINT fk_fact_servicios_tiempo FOREIGN KEY ("TiempoKey")
    REFERENCES dim_tiempo("tiempo_key");

  ALTER TABLE fact_servicios
    ADD CONSTRAINT fk_fact_servicios_cliente FOREIGN KEY ("ClienteKey")
    REFERENCES dim_cliente("ClienteKey");

  ALTER TABLE fact_servicios
    ADD CONSTRAINT fk_fact_servicios_sede_origen FOREIGN KEY ("SedeOrigenKey")
    REFERENCES dim_sede("SedeKey");

  ALTER TABLE fact_servicios
    ADD CONSTRAINT fk_fact_servicios_sede_destino FOREIGN KEY ("SedeDestinoKey")
    REFERENCES dim_sede("SedeKey");

  ALTER TABLE fact_servicios
    ADD CONSTRAINT fk_fact_servicios_mensajero FOREIGN KEY ("MensajeroKey")
    REFERENCES dim_mensajero("MensajeroKey");

facts_fk_novedades: |
  -- 6. FKs para fact_novedades
  ALTER TABLE fact_novedades
    ADD CONSTRAINT fk_fn_tiempo FOREIGN KEY ("TiempoKey")
    REFERENCES dim_tiempo("tiempo_key");

  ALTER TABLE fact_novedades
    ADD CONSTRAINT fk_fn_mensajero FOREIGN KEY ("MensajeroKey")
    REFERENCES dim_mensajero("MensajeroKey");

  ALTER TABLE fact_novedades
    ADD CONSTRAINT fk_fn_cliente FOREIGN KEY ("ClienteKey")
    REFERENCES dim_cliente("ClienteKey");

  ALTER TABLE fact_novedades
    ADD CONSTRAINT fk_fn_sede FOREIGN KEY ("SedeKey")
    REFERENCES dim_sede("SedeKey");

etl_strategy: |
  -- 7. Estrategia ETL mejorada para manejo de duplicados

  -- Función para identificar y limpiar duplicados problemáticos
  CREATE OR REPLACE FUNCTION limpiar_duplicados_servicios() RETURNS void AS $$
  BEGIN
    DELETE FROM fact_servicios
    WHERE servicio_id IN (
      SELECT fs2.servicio_id
      FROM fact_servicios fs1
      JOIN fact_servicios fs2 ON 
        fs1."ServicioKey" = fs2."ServicioKey" AND
        fs1."TiempoKey" = fs2."TiempoKey" AND
        fs1.servicio_id < fs2.servicio_id
    );
  END;
  $$ LANGUAGE plpgsql;
